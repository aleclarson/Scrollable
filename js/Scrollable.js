// Generated by CoffeeScript 1.11.1
var Children, Device, DragResponder, Event, Null, Number, ReactType, RootSection, Rubberband, Style, View, assertType, clampValue, emptyFunction, isDev, isType, ref, type;

ref = require("react-validators"), Style = ref.Style, Children = ref.Children;

Number = require("Nan").Number;

DragResponder = require("DragResponder");

emptyFunction = require("emptyFunction");

Rubberband = require("Rubberband");

assertType = require("assertType");

clampValue = require("clampValue");

ReactType = require("modx/lib/Type");

Device = require("modx/lib/Device");

isType = require("isType");

isDev = require("isDev");

Event = require("Event");

View = require("modx/lib/View");

Null = require("Null");

RootSection = require("./RootSection");

type = ReactType("Scrollable");

type.defineOptions({
  axis: DragResponder.Axis.isRequired,
  offset: Number,
  endThreshold: Number.withDefault(0),
  fastThreshold: Number.withDefault(0.2),
  stretchLimit: Number,
  elasticity: Number.withDefault(0.7)
});

type.initArgs(function(arg) {
  var options;
  options = arg[0];
  return options.stretchLimit != null ? options.stretchLimit : options.stretchLimit = options.axis === "x" ? Device.width : Device.height;
});

type.defineStatics({
  Row: {
    lazy: function() {
      return require("./Row");
    }
  },
  Section: {
    lazy: function() {
      return require("./Section");
    }
  },
  Child: {
    lazy: function() {
      return require("./Child");
    }
  }
});

type.defineReactiveValues({
  _visibleLength: null,
  _contentLength: null,
  _reachedEnd: false,
  _touchable: true
});

type.defineValues(function(options) {
  return {
    didScroll: Event({
      argTypes: {
        offset: Number
      }
    }),
    didLayout: Event(),
    didReachEnd: Event(),
    _children: null,
    _endOffset: null,
    _edgeIndex: null,
    _edgeOffsets: [],
    _fastThreshold: options.fastThreshold
  };
});

type.defineFrozenValues(function(options) {
  return {
    _endThreshold: options.endThreshold,
    _drag: DragResponder({
      axis: options.axis,
      offset: options.offset,
      canDrag: (function(_this) {
        return function(gesture) {
          return _this.__canDrag(gesture);
        };
      })(this),
      shouldCaptureOnStart: (function(_this) {
        return function(gesture) {
          return _this.__shouldCaptureOnStart(gesture);
        };
      })(this)
    }),
    _edge: Rubberband({
      maxValue: options.stretchLimit,
      maxVelocity: 3,
      elasticity: options.elasticity
    })
  };
});

type.defineReactions({
  _edgeDelta: function() {
    var maxOffset, minOffset, offset;
    offset = 0 - this._drag.offset.get();
    if (offset < (minOffset = this.minOffset)) {
      this._edgeIndex = 0;
      this._edge.delta = minOffset - offset;
    } else if (offset > (maxOffset = this.maxOffset)) {
      this._edgeIndex = 1;
      this._edge.delta = offset - maxOffset;
    } else {
      this._edgeIndex = null;
      this._edge.delta = 0;
    }
  },
  _containerEvents: function() {
    if (this._touchable) {
      return "auto";
    } else {
      return "none";
    }
  },
  _offset: function() {
    var offset;
    offset = 0 - this._drag.offset.get();
    offset = this.__computeOffset(offset, this.minOffset, this.maxOffset);
    isDev && assertType(offset, Number);
    return Device.round(0 - offset);
  }
});

type.defineListeners(function() {
  return (function(_this) {
    return function() {
      _this._offset.didSet(_this._offsetDidChange);
      _this._drag.didGrant(_this._dragDidStart);
      _this._drag.didDrag(function(gesture) {
        return _this.__dragDidMove(gesture);
      });
      return _this._drag.didRelease(function(gesture) {
        return _this.__dragDidEnd(gesture);
      });
    };
  })(this)();
});

type.defineGetters((function() {
  var aliases, getters;
  aliases = {
    "gesture": "gesture",
    "axis": "axis",
    "isHorizontal": "isHorizontal",
    isDragging: "isActive",
    didDragReject: "didReject",
    didDragStart: "didGrant",
    "didDrag": "didDrag",
    didDragEnd: "didRelease",
    "didTouchStart": "didTouchStart",
    "didTouchMove": "didTouchMove",
    "didTouchEnd": "didTouchEnd"
  };
  getters = {};
  Object.keys(aliases).forEach(function(alias) {
    var key;
    key = aliases[alias];
    return getters[alias] = function() {
      return this._drag[key];
    };
  });
  return getters;
})());

type.defineGetters({
  contentLength: function() {
    return this._contentLength;
  },
  visibleLength: function() {
    return this._visibleLength;
  },
  edgeOffset: function() {
    if (this._edgeIndex === null) {
      return null;
    }
    return this._edgeOffsets[this._edgeIndex] || 0;
  },
  inBounds: function() {
    return this._edgeIndex === null;
  },
  isRebounding: function() {
    return this._edge.isRebounding;
  },
  hasChildren: function() {
    return this._children !== null;
  }
});

type.definePrototype({
  offset: {
    get: function() {
      return 0 - this._offset.get();
    },
    set: function(offset) {
      return this._drag.offset.set(0 - offset);
    }
  },
  minOffset: {
    get: function() {
      return this._edgeOffsets[0] || 0;
    },
    set: function(minOffset) {
      return this._edgeOffsets[0] = Device.round(minOffset);
    }
  },
  maxOffset: {
    get: function() {
      return this._edgeOffsets[1] || 0;
    },
    set: function(maxOffset) {
      return this._edgeOffsets[1] = Device.round(maxOffset);
    }
  },
  isTouchable: {
    get: function() {
      return this._touchable;
    },
    set: function(isTouchable) {
      return this._touchable = isTouchable;
    }
  }
});

type.defineMethods({
  createChildren: function() {
    if (this._children) {
      throw Error("'createChildren' cannot be called more than once!");
    }
    return this._children = RootSection({
      scroll: this
    });
  },
  scrollTo: function(offset, config) {
    if (isDev) {
      assertType(offset, Number);
      assertType(config, Object);
    }
    config.toValue = 0 - offset;
    return this._drag.offset.animate(config);
  },
  stopScrolling: function() {
    this._drag.offset.stopAnimation();
    this._edge.isRebounding && this._edge.stopRebounding();
  },
  _onLayout: function() {
    this._reachedEnd = false;
    this._updateReachedEnd(this._offset.get(), this._endOffset);
    this.didLayout.emit();
  },
  _setContentLength: function(newLength) {
    if (newLength === this._contentLength) {
      return;
    }
    this._contentLength = newLength;
    this._updateEndOffset(newLength, this._visibleLength);
    this._onLayout();
  },
  _setVisibleLength: function(newLength) {
    if (newLength === this._visibleLength) {
      return;
    }
    this._visibleLength = newLength;
    if (this._updateEndOffset(this._contentLength, newLength)) {
      this._onLayout();
    }
  },
  _updateEndOffset: function(contentLength, visibleLength) {
    var endOffset;
    endOffset = null;
    if ((contentLength !== null) && (visibleLength !== null)) {
      endOffset = this.__computeEndOffset(contentLength, visibleLength);
      isDev && assertType(endOffset, Number.or(Null));
    }
    if (endOffset !== this._endOffset) {
      this._endOffset = endOffset;
      return true;
    }
    return false;
  },
  _updateReachedEnd: function(offset, endOffset) {
    var newValue;
    newValue = this.__isEndReached(offset, endOffset);
    if (this._reachedEnd === newValue) {
      return;
    }
    if (this._reachedEnd = newValue) {
      this.didReachEnd.emit();
    }
  },
  _rebound: function(velocity) {
    this.stopScrolling();
    if (this._edgeIndex === 0) {
      velocity *= -1;
    }
    if (velocity > 0) {
      velocity *= 300;
    }
    return this._edge.rebound({
      velocity: velocity,
      onUpdate: this._reboundDidUpdate,
      onEnd: this._reboundDidEnd
    });
  },
  _isScrollingFast: function() {
    if (!this.__isScrolling()) {
      return false;
    }
    return this._fastThreshold < Math.abs(this.__getVelocity());
  },
  _computeRawOffset: function() {
    if (this._edgeIndex !== null) {
      if (this._edgeIndex === 0) {
        return this.edgeOffset - this._edge.resist();
      }
      return this.edgeOffset + this._edge.resist();
    }
    return clampValue(0 - this._drag.offset.get(), this.minOffset, this.maxOffset);
  },
  _updateEdgeOffsets: function() {
    this._edgeOffsets = [Device.round(this.__computeMinOffset()), Device.round(this.__computeMaxOffset())];
  },
  _isChildVisible: function(child) {
    var endOffset, offset, section, visibleEnd, visibleStart;
    section = child.section, offset = child.offset;
    visibleStart = this.offset;
    visibleEnd = visibleStart + this.visibleLength;
    while (section !== null) {
      if (section.inVisibleArea === false) {
        return false;
      }
      offset += section.startOffset;
      if (offset > visibleEnd) {
        return false;
      }
      section = section.section;
    }
    endOffset = offset + child.length;
    if (endOffset < visibleStart) {
      return false;
    }
    return {
      startOffset: Math.max(visibleStart, offset),
      endOffset: Math.min(visibleEnd, endOffset)
    };
  }
});

type.defineBoundMethods({
  _dragDidStart: function(gesture) {
    this.stopScrolling();
    gesture._startOffset = 0 - this._computeRawOffset();
    this.__dragDidStart(gesture);
  },
  _offsetDidChange: function(offset) {
    if (this.inBounds) {
      this._updateReachedEnd(offset, this._endOffset);
    }
    this.__offsetDidChange(offset);
    this.didScroll.emit(offset);
  },
  _reboundDidUpdate: function(offset) {
    this.__reboundDidUpdate(offset);
  },
  _reboundDidEnd: function(finished) {
    finished && (this._edgeIndex = null);
    this.__reboundDidEnd(finished);
  }
});

type.defineHooks({
  __shouldUpdate: emptyFunction.thatReturnsFalse,
  __shouldCaptureOnStart: function() {
    if (this._edge.isRebounding) {
      return this._edge.delta > 10;
    }
    return this._isScrollingFast();
  },
  __canDrag: emptyFunction.thatReturnsTrue,
  __canScroll: function() {
    return this._endOffset !== null;
  },
  __isScrolling: function() {
    return this._drag.offset.isAnimating;
  },
  __getVelocity: function() {
    var anim;
    anim = this._drag.offset._animation;
    if (anim) {
      return anim.velocity;
    } else {
      return 0;
    }
  },
  __isEndReached: function(offset, endOffset) {
    return (endOffset !== null) && (endOffset !== 0) && (endOffset - this._endThreshold <= offset);
  },
  __dragDidStart: emptyFunction,
  __dragDidMove: emptyFunction,
  __dragDidEnd: function(gesture) {
    var velocity;
    if (this.inBounds) {
      return;
    }
    velocity = gesture.velocity;
    if (this._edgeIndex === 0) {
      velocity *= -1;
    }
    return this._rebound(velocity);
  },
  __computeOffset: function(offset, minOffset, maxOffset) {
    if (this._edgeIndex === null) {
      return clampValue(offset, minOffset, maxOffset);
    }
    if (this._edgeIndex === 0) {
      return this.edgeOffset - this._edge.resist();
    }
    return this.edgeOffset + this._edge.resist();
  },
  __computeEndOffset: function(contentLength, visibleLength) {
    if (contentLength === null) {
      return null;
    }
    if (visibleLength === null) {
      return null;
    }
    return Math.max(0, contentLength - visibleLength);
  },
  __computeMinOffset: function() {
    return 0;
  },
  __computeMaxOffset: function() {
    if (this._endOffset === null) {
      return 0;
    }
    if (this.visibleLength === null) {
      return 0;
    }
    return Math.max(0, this._endOffset - this.visibleLength);
  },
  __offsetDidChange: emptyFunction,
  __reboundDidUpdate: emptyFunction,
  __reboundDidEnd: emptyFunction,
  __childWillAttach: emptyFunction.thatReturnsArgument,
  __childDidAttach: emptyFunction,
  __childWillDetach: emptyFunction,
  __childWillMount: emptyFunction,
  __childDidLayout: emptyFunction,
  __childDidReveal: emptyFunction,
  __childDidConceal: emptyFunction
});

type.defineProps({
  style: Style,
  children: Children
});

type.defineStyles({
  container: {
    overflow: "hidden"
  },
  contents: {
    alignItems: "stretch",
    justifyContent: "flex-start",
    flexDirection: function() {
      if (this.isHorizontal) {
        return "row";
      } else {
        return "column";
      }
    },
    translateX: function() {
      if (this.isHorizontal) {
        return this._offset;
      }
    },
    translateY: function() {
      if (!this.isHorizontal) {
        return this._offset;
      }
    }
  }
});

type.render(function() {
  return View({
    style: [this.props.style, this.styles.container()],
    children: this.__renderContents(),
    pointerEvents: this._pointerEvents,
    mixins: [this._drag.touchHandlers],
    onLayout: (function(_this) {
      return function(event) {
        var key, layout;
        layout = event.nativeEvent.layout;
        key = _this.isHorizontal ? "width" : "height";
        return _this._setVisibleLength(layout[key]);
      };
    })(this)
  });
});

type.defineHooks({
  __renderHeader: emptyFunction.thatReturnsFalse,
  __renderFooter: emptyFunction.thatReturnsFalse,
  __renderEmpty: emptyFunction.thatReturnsFalse,
  __renderOverlay: emptyFunction.thatReturnsFalse,
  __renderContents: function() {
    if (this._children) {
      return this._children.render({
        style: this.styles.contents()
      });
    }
    return View({
      style: this.styles.contents(),
      children: this.props.children,
      onLayout: (function(_this) {
        return function(event) {
          var key, layout;
          layout = event.nativeEvent.layout;
          key = _this.isHorizontal ? "width" : "height";
          return _this._setContentLength(layout[key]);
        };
      })(this)
    });
  }
});

module.exports = type.build();
